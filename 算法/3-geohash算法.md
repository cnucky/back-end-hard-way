## geohash算法原理及实现方式

**geohash有以下几个特点：**

首先，geohash用一个字符串表示经度和纬度两个坐标。某些情况下无法在两列上同时应用索引 （例如MySQL 4之前的版本，Google App Engine的数据层等），利用geohash，只需在一列上应用索引即可。

其次，geohash表示的并不是一个点，而是一个矩形区域。比如编码wx4g0ec19，它表示的是一个矩形区域。 使用者可以发布地址编码，既能表明自己位于北海公园附近，又不至于暴露自己的精确坐标，有助于隐私保护。

第三，编码的前缀可以表示更大的区域。例如wx4g0ec1，它的前缀wx4g0e表示包含编码wx4g0ec1在内的更大范围。 这个特性可以用于附近地点搜索。首先根据用户当前坐标计算geohash（例如wx4g0ec1）然后取其前缀进行查询 （SELECT * FROM place WHERE geohash LIKE 'wx4g0e%'），即可查询附近的所有地点。

Geohash比直接用经纬度的高效很多。

 

**Geohash的原理**

**Geohash的最简单的解释就是：将一个经纬度信息，转换成一个可以排序，可以比较的字符串编码**

        首先将纬度范围(-90, 90)平分成两个区间(-90,0)、(0, 90)，如果目标纬度位于前一个区间，则编码为0，否则编码为1。

由于39.92324属于(0, 90)，所以取编码为1。

然后再将(0, 90)分成 (0, 45), (45, 90)两个区间，而39.92324位于(0, 45)，所以编码为0。

以此类推，直到精度符合要求为止，得到纬度编码为1011 1000 1100 0111 1001。

| 纬度范围           | 划分区间0          | 划分区间1          | 39.92324所属区间 |
| ------------------ | ------------------ | ------------------ | ---------------- |
| (-90, 90)          | (-90, 0.0)         | (0.0, 90)          | 1                |
| (0.0, 90)          | (0.0, 45.0)        | (45.0, 90)         | 0                |
| (0.0, 45.0)        | (0.0, 22.5)        | (22.5, 45.0)       | 1                |
| (22.5, 45.0)       | (22.5, 33.75)      | (33.75, 45.0)      | 1                |
| (33.75, 45.0)      | (33.75, 39.375)    | (39.375, 45.0)     | 1                |
| (39.375, 45.0)     | (39.375, 42.1875)  | (42.1875, 45.0)    | 0                |
| (39.375, 42.1875)  | (39.375, 40.7812)  | (40.7812, 42.1875) | 0                |
| (39.375, 40.7812)  | (39.375, 40.0781)  | (40.0781, 40.7812) | 0                |
| (39.375, 40.0781)  | (39.375, 39.7265)  | (39.7265, 40.0781) | 1                |
| (39.7265, 40.0781) | (39.7265, 39.9023) | (39.9023, 40.0781) | 1                |
| (39.9023, 40.0781) | (39.9023, 39.9902) | (39.9902, 40.0781) | 0                |
| (39.9023, 39.9902) | (39.9023, 39.9462) | (39.9462, 39.9902) | 0                |
| (39.9023, 39.9462) | (39.9023, 39.9243) | (39.9243, 39.9462) | 0                |
| (39.9023, 39.9243) | (39.9023, 39.9133) | (39.9133, 39.9243) | 1                |
| (39.9133, 39.9243) | (39.9133, 39.9188) | (39.9188, 39.9243) | 1                |
| (39.9188, 39.9243) | (39.9188, 39.9215) | (39.9215, 39.9243) | 1                |

 

经度也用同样的算法，对(-180, 180)依次细分，得到116.3906的编码为1101 0010 1100 0100 0100。

| 经度范围           | 划分区间0          | 划分区间1          | 116.3906所属区间 |
| ------------------ | ------------------ | ------------------ | ---------------- |
| (-180, 180)        | (-180, 0.0)        | (0.0, 180)         | 1                |
| (0.0, 180)         | (0.0, 90.0)        | (90.0, 180)        | 1                |
| (90.0, 180)        | (90.0, 135.0)      | (135.0, 180)       | 0                |
| (90.0, 135.0)      | (90.0, 112.5)      | (112.5, 135.0)     | 1                |
| (112.5, 135.0)     | (112.5, 123.75)    | (123.75, 135.0)    | 0                |
| (112.5, 123.75)    | (112.5, 118.125)   | (118.125, 123.75)  | 0                |
| (112.5, 118.125)   | (112.5, 115.312)   | (115.312, 118.125) | 1                |
| (115.312, 118.125) | (115.312, 116.718) | (116.718, 118.125) | 0                |
| (115.312, 116.718) | (115.312, 116.015) | (116.015, 116.718) | 1                |
| (116.015, 116.718) | (116.015, 116.367) | (116.367, 116.718) | 1                |
| (116.367, 116.718) | (116.367, 116.542) | (116.542, 116.718) | 0                |
| (116.367, 116.542) | (116.367, 116.455) | (116.455, 116.542) | 0                |
| (116.367, 116.455) | (116.367, 116.411) | (116.411, 116.455) | 0                |
| (116.367, 116.411) | (116.367, 116.389) | (116.389, 116.411) | 1                |
| (116.389, 116.411) | (116.389, 116.400) | (116.400, 116.411) | 0                |
| (116.389, 116.400) | (116.389, 116.394) | (116.394, 116.400) | 0                |

接下来将经度和纬度的编码合并，奇数位是纬度，偶数位是经度，得到编码 11100 11101 00100 01111 00000 01101 01011 00001。

最后，用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，得到(39.92324, 116.3906)的编码为wx4g0ec1。

| 十进制 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| base32 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | b    | c    | d    | e    | f    | g    |
| 十进制 | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   |
| base32 | h    | j    | k    | m    | n    | p    | q    | r    | s    | t    | u    | v    | w    | x    | y    | z    |

 

解码算法与编码算法相反，先进行base32解码，然后分离出经纬度，最后根据二进制编码对经纬度范围进行细分即可，这里不再赘述。



**观点讨论**

引用阿里云以为技术专家的博客上的讨论：

1.两个离的越近，geohash的结果相同的位数越多，对么？
这一点是有些用户对geohash的误解，虽然geo确实尽可能的将位置相近的点hash到了一起，可是这并不是严格意义上的(实际上也并不可能，因为毕竟多一维坐标)，
例如在方格4的左下部分的点和大方格1的右下部分的点离的很近，可是它们的geohash值一定是相差的相当远，因为头一次的分块就相差太大了，很多时候我们对geohash的值进行简单的排序比较，结果貌似真的能够找出相近的点，并且似乎还是按照距离的远近排列的，可是实际上会有一些点被漏掉了。
上述这个问题，可以通过搜索一个格子，周围八个格子的数据，统一获取后再进行过滤。这样就在编码层次解决了这个问题。

 1）由于GeoHash是将区域划分为一个个规则矩形，并对每个矩形进行编码，这样在查询附近POI信息时会导致以下问题，比如红色的点是我们的位置，绿色的两个点分别是附近的两个餐馆，但是在查询的时候会发现距离较远餐馆的GeoHash编码与我们一样（因为在同一个GeoHash区域块上），而较近餐馆的GeoHash编码与我们不一致。这个问题往往产生在边界处。

![img](https://images0.cnblogs.com/blog/522490/201309/09190137-edd3b1fe3d754c5d836e2812ac298674.png)

解决的思路很简单，我们查询时，除了使用定位点的GeoHash编码进行匹配外，还使用周围8个区域的GeoHash编码，这样可以避免这个问题。 

2）我们已经知道现有的GeoHash算法使用的是Peano空间填充曲线，这种曲线会产生突变，造成了编码虽然相似但距离可能相差很大的问题，因此在查询附近餐馆时候，首先筛选GeoHash编码相似的POI点，然后进行实际距离计算。

 

常见的一些应用场景

A、如果想查询附近的点？如何操作

查出改点的gehash值，然后到数据库里面进行前缀匹配就可以了。

 

B、如果想查询附近点，特定范围内，例如一个点周围500米的点，如何搞？

可以查询结果，在结果中进行赛选，将geohash进行解码为经纬度，然后进行比较

 

 *在纬度相等的情况下：

 *经度每隔0.00001度，距离相差约1米；

 *每隔0.0001度，距离相差约10米；

 *每隔0.001度，距离相差约100米；

 *每隔0.01度，距离相差约1000米；

 *每隔0.1度，距离相差约10000米。

 *在经度相等的情况下：

 *纬度每隔0.00001度，距离相差约1.1米；

 *每隔0.0001度，距离相差约11米；

 *每隔0.001度，距离相差约111米；

 *每隔0.01度，距离相差约1113米；

 *每隔0.1度，距离相差约11132米。

Geohash，如果geohash的位数是6位数的时候，大概为附近1千米



转载自：https://www.cnblogs.com/dengxinglin/archive/2012/12/14/2817761.html