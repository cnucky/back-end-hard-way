有网银的少年们一般都收到过银行给的这样一个令牌，俗称动态口令，在支付的时候输入自己的密码和动态口令上的动态密码，就能完成验证，银行就相信你不是坏人了，今天我们来简述一下这个动态口令令牌是个什么原理。 

![totp1](C:\Users\BG235145\Desktop\wtg\resource\totp1.jpg)

如图的RSA SecurID SID700是当前市面上流行使用的动态口令令牌，在笔者准备资料的过程中发现国内描写动态口令的野生博客有不少谬误，其中大多是对银行这一套认证机制结构的不了解，所以首先要强调的是：

>  在大众用户手中的动态口令令牌，并不使用任何对称或者非对称加密的算法，在整个银行的认证体系中，动态口令令牌只是一个一次性口令的产生器，在其中运行的主要计算仅包括时间因子的计算和散列值的计算。 

动态口令算法又叫一次性口令算法，英文写作OTP(One-Time Password Algorithm), 动态口令令牌使用的算法是OTP中的一类，TOTP(Time-Based One-Time Password Algorithm) --- 时间同步型动态口令。

时间同步型动态口令产生口令的时候和时间有关系，我们可以通过其工作的原理图来看一下：![topt2](C:\Users\BG235145\Desktop\wtg\resource\topt2.png)



图示给出了动态口令的工作原理，突出了整个认证机制中的动态口令部分，我们可以清楚看到在最左边和最右边有完全相同的两个流程，这里分别代表了用户的令牌卡和银行服务器的验证机器做的工作。本文的重点就在这两个完全相同的流程上。

在用户从银行手中拿到动态口令令牌卡的时候，在令牌卡的内部已经存储了一份种子文件(即图中钥匙所代表的seed)，这份种子文件在银行的服务器里保存的完全一样的一份，所以对于动态口令令牌来说，这种方式是 share secret的。另外在令牌硬件上的设置中，假使有人打开了这个令牌卡，种子文件将会从令牌卡的内存上擦除（待考证）。

令牌卡中有了种子文件，并实现了 TOTP 算法，在预先设置的间隔时间里它就能不断产生不同的动态口令，并显示到屏幕上，而银行服务器上跟随时间做同样的计算，也会得到和令牌卡同样的口令，用作认证。

那么 TOTP 算法具体做了什么操作呢？在 [RFC6238](http://link.zhihu.com/?target=http%3A//tools.ietf.org/html/rfc6238) 中有详细的算法描述，这里也会做简单的叙述。

TOTP 是来自 HOTP [[RFC4226](http://link.zhihu.com/?target=http%3A//tools.ietf.org/html/rfc4226)] 的变形，从统筹上看，他们都是将数据文件进行散列计算，只是HOTP的因子是事件因子，TOTP将因子换成了时间因子，具体的TOTP计算公式(其中的HMAC-SHA-256 也可能是 HMAC-SHA-512)：

> TOTP = Truncate(HMAC-SHA-256(K,T))
>
> 其中： K 为这里的种子文件内容； T 为计算出来的时间因子

公式中的 HMAC是密钥相关的哈希运算消息认证码(Hash-based Message Authentication Code)，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。而公式中给出的哈希算法是 SHA-256，这种哈希算法目前并没有好的破解办法。

令牌卡中预先设置了要显示的口令长度，TOTP 中的 Truncate 操作剪切获得口令。

以上就是动态口令令牌卡的内部原理。

 

 补充： 

（1）事实上，服务端验证口令的时候，会取多个时间戳生成口令与客户端口令进行比较，以防止客户端、服务端时间不同步。

（2）客户端密钥seed和加密方式一旦暴露，相当于密码暴露，所以需要定时替换seed或加密方式。

 